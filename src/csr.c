//#include <string.h>
//#include <stdio.h>
//#include <stdlib.h>
//#include <stdint.h>
//#include <omp.h>
//#include "allocator.h"
#include "geometry.h"
#include "mesh2geo.h"

#if 0
static void scan(const size_t nrows, unsigned int *array)
{
  unsigned int sum = 0;
  for(unsigned int i = 0; i <= nrows; i++)
  {
    const unsigned int t = array[i];
    array[i] = sum;
    sum += t;
  }
}

/* c stdlib qsort comparable function */
static inline int 
comp(const void *a, const void *b)
{
  return (int) (*((uint32_t *) a) - *((uint32_t *) b));
}
#endif
void
m2csr(struct geometry *g)
{
#if 0
  /* Row pointers */
  uint32_t *ia = (uint32_t *) fun3d_calloc((g->n->sz + 1), sizeof(uint32_t));

  uint32_t i;
 
  for(i = 0; i < g->e->sz; i++)
  {
    ia[g->e->eptr->n0[i]]++;
    ia[g->e->eptr->n1[i]]++;
  }

  for(i = 0; i <= g->n->sz; i++) ia[i]++;

  scan(g->n->sz, ia);

  // Add one to avoid 'segmentation fault generated by METIS
  // Need to be tested
  uint32_t *ja = (uint32_t *) fun3d_calloc((ia[g->n->sz] + 1), sizeof(uint32_t));
  double *aa = (double *) fun3d_calloc(ia[g->n->sz] * 4 * 4, sizeof(double));
  
  /* A temp buffer used to keep tracking of each row elements */
  uint32_t *buf = (uint32_t *) fun3d_malloc(g->n->sz, sizeof(uint32_t));

  /* Column Index of the diagonal elements */
  for(i = 0; i < g->n->sz; i++)
  {
    ja[ia[i]] = i; // A diagonal element
    buf[i] = 1; // One element in this row has been added
  }

  /* Fill the rest of the array, ordered by RCM and using a 
   * modified version of Breadth-First Search traversing algorithm */
  for(i = 0; i < g->e->sz; i++)
  {
    uint32_t n0 = g->e->eptr->n0[i];
    uint32_t n1 = g->e->eptr->n1[i];

    /* Get the element index in the row 
     * The index is basically the row index plus the last element that
     * has been added in the row. */
    uint32_t indx = ia[n0] + buf[n0]; // Get the index
    buf[n0]++; // Column has been added (one more element in the row)
    ja[indx] = n1; // Store the node index in its corresponding index

    /* Do it for the other endpoint */
    indx = ia[n1] + buf[n1];
    buf[n1]++;
    ja[indx] = n0;
  }

  fun3d_free(buf);

  uint32_t *diag = (uint32_t *) fun3d_calloc(g->n->sz, sizeof(uint32_t));
  unsigned int *w = (unsigned int *) fun3d_calloc(g->n->sz, sizeof(unsigned int));

  /* Sort the each row of a ja array in an increasing order  
   * No we reorder them again to make sure the at each row 
   * we have the node ordered in increasing order plus based on 
   * their degree */
#pragma omp parallel for
  for(i = 0; i < g->n->sz; i++)
  {
    const uint32_t jstart = ia[i];
    const uint32_t jend = ia[i+1];

    const size_t nnz_per_row = ia[i+1] - ia[i];

    qsort(ja + jstart, nnz_per_row, sizeof(uint32_t), comp);

    uint32_t j;
    for(j = jstart; j < jend; j++)
    {
      if(ja[j] == i)
      {
        diag[i] = j; // Store a diagonal element
        break;
      }
    }
  }

  struct mat *csr = (struct mat *) fun3d_malloc(1, sizeof(struct mat));

  csr->a = aa;
  csr->i = ia;
  csr->j = ja;
  csr->d = diag;
  csr->w = w;
  g->c->mat = csr;
#endif

  /* Incompressible Euler flow */
  g->c->b = 4;
  g->c->b2 = 4 * 4;
  
  /* Solution vector length: matrix rows x DoFs */
  g->c->sz = g->c->b * g->n->sz;
}