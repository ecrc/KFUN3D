#ifdef __cplusplus
extern "C" {
#endif
extern void CXX_METIS(const unsigned int nparts, unsigned int *parts, void *ptr);
#ifdef __cplusplus
}
#endif

#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include <omp.h>
//#include <metis.h>
#include "allocator.h"
#include "geometry.h"
#include "mesh2geo.h"

static void
emalloc_sub(struct geometry * g)
{
  const uint32_t threads = (uint32_t) omp_get_max_threads();

  struct etbl *e = (struct etbl *) fun3d_malloc(1, sizeof(struct etbl));

  struct edge *eptr = (struct edge *) fun3d_malloc(1, sizeof(struct edge));

  struct xyzn * xyzn = (struct xyzn *) fun3d_malloc(1, sizeof(struct xyzn));

  /* Number of the edges with replications means that 
   * some edges have been replicated (redundantly copied) to 
   * each thread to avoid communication */
  e->sz = g->s->i[threads];

  eptr->n0 = (uint32_t *) fun3d_malloc(e->sz, sizeof(uint32_t));
  eptr->n1 = (uint32_t *) fun3d_malloc(e->sz, sizeof(uint32_t));

  xyzn->x0 = (double *) fun3d_malloc(e->sz, sizeof(double));
  xyzn->x1 = (double *) fun3d_malloc(e->sz, sizeof(double));
  xyzn->x2 = (double *) fun3d_malloc(e->sz, sizeof(double));
  xyzn->x3 = (double *) fun3d_malloc(e->sz, sizeof(double));

  e->eptr = eptr;
  e->xyzn = xyzn;

  uint32_t *buf = (uint32_t *) fun3d_malloc((size_t) threads, sizeof(uint32_t));

  /* Copy the data from the original start edges index to the temporary
   * buffer */
  memcpy(buf, g->s->i, (size_t) threads * sizeof(uint32_t));
  
  /* Scan the edges and color them based on their subdomains
   * that they belong to */
  uint32_t i;
  for(i = 0; i < g->e->sz; i++)
  {
    /* Get the thread IDs that this edge belongs to. The edge could
     * could be belong to two different threads. */
    uint32_t t0 = g->n->part[g->e->eptr->n0[i]];
    uint32_t t1 = g->n->part[g->e->eptr->n1[i]];

    /* Do the first thread */
    
    /* Store the edges' endpoints pointers in a new array that 
     * is indexed based upon their partition indices. */
    e->eptr->n0[buf[t0]] =  g->e->eptr->n0[i];
    e->eptr->n1[buf[t0]] =  g->e->eptr->n1[i];

    /* Store the edges' normals in a new array that is indexed
     * based upon their partition indices. */
    e->xyzn->x0[buf[t0]] = g->e->xyzn->x0[i];
    e->xyzn->x1[buf[t0]] = g->e->xyzn->x1[i];
    e->xyzn->x2[buf[t0]] = g->e->xyzn->x2[i];
    e->xyzn->x3[buf[t0]] = g->e->xyzn->x3[i];

    /* Move the index pointer by one so that we do not overwrite the
     * initial results of the current thread data.  */
    buf[t0]++;

    /* Do the second thread */

    /* Do the same processing if the second endpoint belongs to a 
     * different thread */
    if(t0 != t1)
    {
      /* Edge nodes pointers */
      e->eptr->n0[buf[t1]] = g->e->eptr->n0[i];
      e->eptr->n1[buf[t1]] = g->e->eptr->n1[i];

      /* Edge normals */
      e->xyzn->x0[buf[t1]] = g->e->xyzn->x0[i];
      e->xyzn->x1[buf[t1]] = g->e->xyzn->x1[i];
      e->xyzn->x2[buf[t1]] = g->e->xyzn->x2[i];
      e->xyzn->x3[buf[t1]] = g->e->xyzn->x3[i];

      buf[t1]++; // Move the index of the second thread
    }

  }

  fun3d_free(buf); // Done from the temporary buffer

  fun3d_free(g->e->eptr->n0);
  fun3d_free(g->e->eptr->n1);
  fun3d_free(g->e->eptr);

  fun3d_free(g->e->xyzn->x0);
  fun3d_free(g->e->xyzn->x1);
  fun3d_free(g->e->xyzn->x2);
  fun3d_free(g->e->xyzn->x3);
  fun3d_free(g->e->xyzn);

  fun3d_free(g->e);

  g->e = e;
}

void
isubdomain(struct geometry * g)
{
  uint32_t *part = (uint32_t *) fun3d_calloc(g->n->sz, sizeof(uint32_t));
  const uint32_t threads = (uint32_t) omp_get_max_threads();
  CXX_METIS(threads, part, g->matrix);
#if 0
  if(threads > 1)
  {
    /* Number of balancing constraints that METIS needs to partitioning
     * the graph. The minimum is 1, which means you want to equidistribute 
     * the workload between the nodes as much as possible. 
     * So, one is the default.
     *
     * For more information, refer to METIS user manual
     * */
    int32_t ncon = 1;
    int32_t ncuts = 0;

    g->c->mat->i[g->n->sz]++; // Just for METIS

    METIS_PartGraphKway(
      (int32_t *) &g->n->sz,
      &ncon,
      (int32_t *) g->c->mat->i,
      (int32_t *) g->c->mat->j,
      NULL,
      NULL,
      NULL,
      (int32_t *) &threads,
      NULL,
      NULL,
      NULL,
      &ncuts,
      (int32_t *) part);

    g->c->mat->i[g->n->sz]--; // Just for METIS

    printf("Number of the edge cuts, generated by METIS is: %d\n", ncuts);
  }
#endif
  uint32_t *ie = (uint32_t *) fun3d_calloc((size_t) (threads + 1), sizeof(uint32_t));

  uint32_t i;
  for(i = 0; i < g->e->sz; i++)
  {
    /* Add 1 is to change the indexing from 0 to 1  */
    uint32_t t0 = part[g->e->eptr->n0[i]]; // Thread id owns the node
    uint32_t t1 = part[g->e->eptr->n1[i]]; // Thread id owns the node

    /* Add work to the first thread */
    ie[t0]++;
    /* If two threads are owning each part of the edge, means 
     * that each thread has one end point then add the second 
     * one as well */
    if(t0 != t1) ie[t1]++;
  }
 
  uint32_t sum = 0;
  for(i = 0; i < (size_t) threads; i++)
  {
    uint32_t temp = ie[i];
    ie[i] = sum;
    sum += temp;
  }
  ie[threads] = sum; // Total number of nonzero blocks

  g->s->i = ie;
  g->s->sz = (size_t) threads;

  g->n->part = part;

  emalloc_sub(g);
}